#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "delay.h"
#include "mh210x.h"
#include <stdint.h>

typedef struct{
	char *name;
	GPIO_TypeDef *port;
	uint16_t pin;
}GPIO_PinConfig;


const  GPIO_PinConfig LED[] = {
        {"GPS", GPIOA, GPIO_Pin_5}, {"WIFI", GPIOA, GPIO_Pin_6}, {"LAN", GPIOA, GPIO_Pin_7},
				{"TF", GPIOC, GPIO_Pin_4}, {"PM1", GPIOC, GPIO_Pin_5}, {"PM2", GPIOB, GPIO_Pin_0},
        {"PM3", GPIOB, GPIO_Pin_1}, {"PM4", GPIOB, GPIO_Pin_10}, {"SIM", GPIOB, GPIO_Pin_11},
				{"12V", GPIOB, GPIO_Pin_12}, {"I/O", GPIOB, GPIO_Pin_13}, {"232", GPIOB, GPIO_Pin_14},
        {"CAN", GPIOB, GPIO_Pin_15}, {"485", GPIOC, GPIO_Pin_6}
    };

void GPIO_Configuration(void) {
    GPIO_InitTypeDef GPIO_InitStructure;

		int i;
		// 使能GPIOA、GPIOB和GPIOC时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC, ENABLE);
		//配置所有引脚为推挽输出模式，速度为50MHz
	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

		for ( i = 0; i < sizeof(LED)/sizeof(LED[0]);i++){
			GPIO_InitStructure.GPIO_Pin = LED[i].pin;
			GPIO_Init(LED[i].port,&GPIO_InitStructure);
		}
}

void GPIO_Config2(void){
	
		GPIO_InitTypeDef GPIO_InitStructure;
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOC, ENABLE);
		GPIO_Remap_SWJ_Disable;
		
	
		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//pu
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOC, &GPIO_InitStructure);
	
		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;//spk
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOA, &GPIO_InitStructure);
	
		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;//pd
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOA, &GPIO_InitStructure);
		
}

void set_pin_high(GPIO_PinConfig gpio){
		GPIO_SetBits(gpio.port,gpio.pin);
}

void set_pin_low(GPIO_PinConfig gpio){
    GPIO_ResetBits(gpio.port, gpio.pin); 
}

void UNART1_ConFiguration(void){
		GPIO_InitTypeDef GPIO_InitStructure;
		USART_InitTypeDef USART_InitStructure;
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1,ENABLE);
		GPIO_InitStructure.GPIO_Pin =GPIO_Pin_9;
		GPIO_InitStructure.GPIO_Mode =GPIO_Mode_AF_PP;
		GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;
		GPIO_Init(GPIOA, &GPIO_InitStructure);
		
		GPIO_InitStructure.GPIO_Pin =GPIO_Pin_10;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
		GPIO_Init(GPIOA, &GPIO_InitStructure);
	
		USART_InitStructure.USART_BaudRate =115200;
		USART_InitStructure.USART_WordLength = USART_WordLength_8b;
		USART_InitStructure.USART_StopBits = USART_StopBits_1;
		USART_InitStructure.USART_Parity = USART_Parity_No ;
		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
		USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
		USART_Init(USART1, &USART_InitStructure);
	
		USART_Cmd(USART1,ENABLE);
	
}

void USART1_SendString(char* str){
		while (*str){
				while(USART_GetFlagStatus(USART1, USART_FLAG_TC) ==RESET){}
					USART_SendData(USART1,*str++);
		}
}

char USART_ReceiveString(char* str ,char end ) {
    int i = 0;
    char received_char;

    while (1) {
        // 等待直到USART1的数据寄存器为空
        while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET) {}
        // 读取接收到的数据
        received_char = USART_ReceiveData(USART1);

        // 如果接收到的字符是结束字符，则退出循环
        if (received_char == end) {
            break;
        }

        // 将接收到的字符存储到字符串中
        str[i] = received_char;
				i++;
				
    }
		if(strlen(str)>10){	
			for ( i = 0;i<14 ; i++) {
					if (str[i] == '1') 
            set_pin_low(LED[i]);
					else
						set_pin_high(LED[i]);
				}
			}
		return (*str);
}

int main(void) {
		
		char receivedString[100];
		int i;
		int autotest =1;
		int singletest=0;
		char USART_ReceiveString(char *str, char end);
		Delay_Init();
    // 调用GPIO配置函数
    GPIO_Configuration();
		GPIO_Config2();
		for ( i = 0; i < sizeof(LED)/sizeof(LED[0]);i++){
				set_pin_high(LED[i]);
		}
		
		Delay_Ms(2000);

		UNART1_ConFiguration();

    while (1) {
        // 主循环，可以添加其他代码
			Delay_Ms(1000);
			for ( i = 0; i < sizeof(LED)/sizeof(LED[0]);i++){
					set_pin_high(LED[i]);
				}
			if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2) == Bit_RESET){
				autotest = 0;
        singletest = 1;
        while (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_2) == Bit_RESET); // 等待按钮释放
				
			}
			Delay_Ms(5000);
			
			if(autotest){
				char str;
				USART1_SendString("AUTOTEST");
				
				set_pin_low(LED[2]);//测试
				Delay_Ms(2000);
				
				set_pin_high(LED[2]);//测试
				Delay_Ms(2000);
				
				str = USART_ReceiveString(receivedString,'\n');
				Delay_Ms(2000);
				
				memset(receivedString, '\0', sizeof(receivedString));
			}
			
			if(singletest){
				char str;
				for ( i = 1; i < sizeof(LED)/sizeof(LED[0]);i++){
					set_pin_low(LED[i]);
				}
					
				i=0;
					
				while(1){
					
					if(	GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_3) == Bit_RESET){
						Delay_Ms(50);
						set_pin_low(LED[i]);
						Delay_Ms(50);
						while(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_3) == Bit_RESET);
						i = (i+1)%(sizeof(LED)/sizeof(LED[0]));
						set_pin_high(LED[i]);
					}
			
					if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1) == Bit_RESET){
							while(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1) == Bit_RESET);
							USART1_SendString(LED[i].name);
							Delay_Ms(2000);
							str = USART_ReceiveString(receivedString, '\n');
							if (str == '1') {
								set_pin_low(LED[i]);
							}
							else
								set_pin_high(LED[i]);
						}
	
					if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2) == Bit_RESET){
						autotest = 1;
						singletest = 0;
						while (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_2) == Bit_RESET); // 等待按钮释放
						break;
						
					}
					memset(receivedString, '\0', sizeof(receivedString));
				}
				
			}
			memset(receivedString, '\0', sizeof(receivedString));
    }
}
